#pragma config(Sensor, in1,    claw,          sensorPotentiometer)
#pragma config(Sensor, in3,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in7,    status,         sensorAnalog)
#pragma config(Sensor, dgtl5,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           leftClaw,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDriveFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftLiftSingle, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLiftDouble, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightLiftDouble, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightLiftSingle, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightDriveFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightClaw,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
enum auton_states {AUTON_COMP, AUTON_SKILLS};
auton_states auton = AUTON_COMP;
const int autonLength = 2;
int currAuton = 1;
bool inMacro;
int button = 1;
bool cmove = false;

void pre_auton()
{

}

bool clamp = false;
void setMotorSignal(int leftSignal, int rightSignal)
{
	motor[leftDriveFront]  = leftSignal;
	motor[leftDriveBack]   = leftSignal;
	motor[rightDriveFront] = rightSignal;
	motor[rightDriveBack]  = rightSignal;
}

task clawControl(){
	int CLOSED  = 500;
	int OPENED  = 1200;
	int signal = 0;
	int increm = 0;
	while(true){
		if(vexRT[Btn5U]){
			clamp = false;
			cmove = false;
			if(SensorValue[claw] < OPENED){
				if(increm > 0)
					increm = 0;
				increm -= 5;
				signal = increm;
			}
			else{
				signal = 10;
			}
		}
		else if(vexRT[Btn5D]){
			clamp = false;
			cmove = false;
			if(SensorValue[claw] > CLOSED){
				if(increm < 0)
					increm = 0;
				increm += 5;
				signal = increm;
			}
			else{
				signal = 0;
			}
		}
		else{
			increm = 0;
			if(SensorValue[claw] > OPENED){
				signal = 20;
			}
			else{
				signal = 0;
				increm = 0;
			}
		}
		if(clamp == false){
			motor[leftClaw] = signal;
			motor[rightClaw] = signal;
		}
	}
}
bool userinput(){
	if(vexRT[Btn5D] || vexRT[Btn5U] || vexRT[Btn6D] || vexRT[Btn6U]){
		return true;
	}
	else{
		return false;
	}
}
int desiredLiftPosition;
task liftControl(){
	int liftpos = 0;
	bool clicked8R = false, clicked7L = false;
	const int LIFT_DOWN = 200;
	int E_STOP = 1200;
	desiredLiftPosition = SensorValue[liftPot];
	int liftSignal = 0;
	const int setPoint = 650;
	int div = 0;
	int scored = -1;
	int clawopen = 1200;
	while(true){
		if(!inMacro){
			if(vexRT[Btn8R] == 1){
				clicked8R = true;
			}
			if(vexRT[Btn8R] == 0 && clicked8R == true)
			{
				liftpos = 1;
				clamp = true;
				cmove = true;
				clicked8R = false;
			}
			if(vexRT[Btn6U]){
				scored = 0;
				liftpos = 0;
				cmove = true;
				int checkavr = (SensorValue[claw]);
				clamp = false;
				while(vexRT[Btn6U] == 1 && SensorValue[liftPot] < 1200 && scored == 0){
					if(SensorValue[liftPot] < 400 + (checkavr / 20) && scored == 0){
						liftSignal = 120;
						motor[leftClaw] = 100;
						motor[rightClaw] = 100;
					}
					else{
						if(SensorValue[claw] < clawopen){
							motor[leftClaw] = -100;
							motor[rightClaw] = -100;
						}
						else{
							motor[rightClaw] = 10;
							motor[leftClaw] = 10;
						}
						if(SensorValue[liftPot] > 1100){
							liftSignal = -120;
							scored = 1;
						}
					}
					motor[leftLiftSingle] = liftSignal;
					motor[leftLiftDouble] = liftSignal;
					motor[rightLiftDouble] = liftSignal;
					motor[rightLiftSingle] = liftSignal;
					if(scored == 1)
						wait1Msec(250);
				}
				if(scored == 1)
				{
					motor[rightClaw] = 40;
					motor[leftClaw] = 40;
				}
				if(scored == 1)
				{
					scored = -1;
				}
				clicked7L = false;
				clamp = true;
				desiredLiftPosition = SensorValue[liftPot];
			}


			if(liftpos == 1)
			{
				if(!vexRT[Btn6U]){
					desiredLiftPosition = setPoint;
				}
			}
			if(vexRT[Btn6D] == 1 && SensorValue[liftPot] > LIFT_DOWN){
				cmove = true;
				clamp = false;
				motor[rightClaw] = 40;
				motor[leftClaw] = 40;
				liftpos = 0;
				liftSignal = -60;
				desiredLiftPosition = SensorValue[liftPot];
			}else if(liftpos != 1 && vexRT[Btn6D] == 0)
			{
				liftSignal = 0;
			}
			if(SensorValue[liftPot] < LIFT_DOWN && desiredLiftPosition != setPoint && desiredLiftPosition != 330){
				liftSignal = -8;
			}
			else {
				if(SensorValue[liftPot] > E_STOP){
					desiredLiftPosition = E_STOP - 100;
				}
				if(abs(desiredLiftPosition - SensorValue[liftPot]) > (float) 30 * (float) 11.6 && SensorValue[liftPot] < desiredLiftPosition)
				{
					div = 1;
				}
				else if(abs(desiredLiftPosition - SensorValue[liftPot]) > (float) 10 * (float) 11.6  && SensorValue[liftPot] < desiredLiftPosition)
				{
					div = 3;
				}
				else
				{
					div = 6;
				}
				if(vexRT[Btn6D] == 0)
					liftSignal = (desiredLiftPosition - SensorValue[liftPot]) / div;
			}
			writeDebugStreamLine("CurrPos: %d, DesiredPos: %d", SensorValue[liftPot], desiredLiftPosition);
			if(liftSignal > 0 && SensorValue[liftPot] > E_STOP - 50)
			{
				liftSignal = liftSignal * -1 / 5;
			}
			motor[leftLiftSingle]  = liftSignal;
			motor[leftLiftDouble]  = liftSignal;
			motor[rightLiftSingle] = liftSignal;
			motor[rightLiftDouble] = liftSignal;
			wait1Msec(30);
		}
	}
}

task autonomous()
{

}
task usercontrol()
{
	bLCDBacklight = true;
	bool buttClicked;
	string powerExpander;
	string mainBattery;
	const int SIZE = 10;
	int oldL[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int oldR[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int sumL = 0, sumR = 0;
	int driveMap[128] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		22,23,24,25,26,27,28,28,29,29,
		30,30,31,31,32,32,33,33,34,34,
		35,35,36,36,37,37,38,38,39,39,
		40,40,41,41,42,42,43,43,44,44,
		45,45,46,46,47,47,48,48,49,49,
		50,50,51,51,52,52,53,53,54,54,
		55,55,56,56,57,57,58,58,59,59,
		60,60,61,62,63,64,65,66,67,68,
		69,70,71,72,73,74,75,76,77,78,
		79,80,81,82,83,84,85,86,87,88,
		89,90,91,92,94,96,127,127};

	startTask(clawControl);
	startTask(liftControl);
	while (true)
	{


		if(nLCDButtons != 0){
			button = nLCDButtons;
			if(button == 4 && !buttClicked){
				currAuton++;
				buttClicked = true;
				if(currAuton > autonLength){
					currAuton = 1;
				}
			}
		}
		if(nLCDButtons == 0){
			buttClicked = false;
		}
		if(currAuton == 1){
			auton = AUTON_COMP;
		}
		if(currAuton == 2){
			auton = AUTON_SKILLS;
		}
		clearLCDLine(0);
		clearLCDLine(1);
		if(button == 1){
			displayLCDString(0,0,"Team: 4659B");
			if(bIfiAutonomousMode){
				displayLCDString(1,0,"Autonomous");
			}
			else if(!bIfiAutonomousMode){
				displayLCDString(1,0,"User Control");
			}
		}
		if(button == 2){
			displayLCDString(0,0,"Battery: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
			displayNextLCDString(mainBattery);
			displayLCDString(1,0,"Expander: ");
			sprintf(powerExpander, "%1.2f%c",(float)SensorValue[status] / 282,'V');
			displayNextLCDString(powerExpander);
			displayNextLCDString("V");
		}
		if(button == 4){
			displayLCDString(0,0,"Auton: ");
			if(auton == AUTON_COMP){
				displayLCDString(1,0,"Competition 1");
			}
			else if(auton == AUTON_SKILLS){
				displayLCDString(1,0,"Skills 1");
			}
		}
		oldL[9] = driveMap[abs(vexRT[Ch3])] * sgn(vexRT[Ch3]);
		oldR[9] = driveMap[abs(vexRT[Ch2])] * sgn(vexRT[Ch2]);
		sumL = 0;
		sumR = 0;
		for(int i = 0; i < SIZE - 1; i++){
			sumL += oldL[i];
			sumR += oldR[i];
			oldL[i] = oldL[i + 1];
			oldR[i] = oldR[i + 1];
		}
		sumL += oldL[9];
		sumR += oldR[9];
		motor[leftDriveFront]  = sumL / SIZE;
		motor[leftDriveBack]   = sumL / SIZE;
		motor[rightDriveFront] = sumR / SIZE;
		motor[rightDriveBack]  = sumR / SIZE;
		wait1Msec(25);
	}
}
