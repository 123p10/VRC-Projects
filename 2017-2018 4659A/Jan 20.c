#pragma config(Sensor, in8,    cb,             sensorPotentiometer)
#pragma config(Sensor, dgtl1,  Lift,           sensorQuadEncoder)
#pragma config(Motor,  port1,           mogoL,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RDB,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RDF,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           cBar,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LiftL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LiftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LDB,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LDF,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mogoR,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

void setLDrive(int speed);
void setRDrive(int speed);
void setLiftSpeed(int speed);
void setMogo(int speed);
void setcBarSpeed(int speed);
void setClaw(int speed);
void chBar(int des);
//void chainBar(int pos);
bool hold = false;

void macro(int n);

	//Drive slew buffer
	const int SIZE = 10; //If updating SIZE, add or remove 0s from arrays below
	int oldL[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  int oldR[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  int sumL = 0, sumR = 0;

  //Higher control drive mapping
  int driveMap[128] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
											 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
											22,23,24,25,26,27,28,28,29,29,
											30,30,31,31,32,32,33,33,34,34,
											35,35,36,36,37,37,38,38,39,39,
											40,40,41,41,42,42,43,43,44,44,
											45,45,46,46,47,47,48,48,49,49,
											50,50,51,51,52,52,53,53,54,54,
											55,55,56,56,57,57,58,58,59,59,
											60,60,61,62,63,64,65,66,67,68,
											69,70,71,72,73,74,75,76,77,78,
											79,80,81,82,83,84,85,86,87,88,
											89,90,91,92,94,96,127,127};
void pre_auton()
{
  bStopTasksBetweenModes = true;
	SensorValue[cBar] = 0;
	SensorValue[Lift] = 0;

}
task autonomous(){}
task usercontrol()
{
	int lAim = 0;
	int lkP = 2;


  while (true)
  {

		oldL[9] = driveMap[abs(vexRT[Ch3])] * sgn(vexRT[Ch3]);
		oldR[9] = driveMap[abs(vexRT[Ch2])] * sgn(vexRT[Ch2]);

		//Reset sums
		sumL = 0;
		sumR = 0;

		//Sum up the previous 10 drive commands
		for(int i = 0; i < SIZE - 1; i++){
			sumL += oldL[i];
			sumR += oldR[i];

			oldL[i] = oldL[i + 1];
			oldR[i] = oldR[i + 1];
		}

		sumL += oldL[9];
		sumR += oldR[9];

		//Drive motors receive moving average
		motor[LDF]  = sumL / SIZE;
	  motor[LDB]   = sumL / SIZE;
	  motor[RDF] = sumR / SIZE;
	  motor[RDB]  = sumR / SIZE;
/*
		//Drive Code
  	if(abs(vexRT[Ch3]) > 15){
  		setLDrive(vexRT[Ch3]);
  	}
  	else{
  		setLDrive(0);
  	}

  	 if(abs(vexRT[Ch2]) > 15){
  		setRDrive(vexRT[Ch2]);
  	}
  	else{
  		setRDrive(0);
  	}*/


		//Lift Code
  	if(vexRT[Btn5U]){
  		setLiftSpeed(127);
  		lAim = SensorValue[Lift];
  	}
  	else if(vexRT[Btn5D]){
  		setLiftSpeed(-127);
  		lAim = SensorValue[Lift];
  	}
  	else{

  		int error = SensorValue[Lift] - lAim;
  		setLiftSpeed(0);
  	}


		//Mogo Code
  	if(vexRT[Btn8U]){
  		setMogo(127);
  	}
  	else if(vexRT[Btn8D]){
  		setMogo(-(127));
  	}
  	else{
  		setMogo(0);
  	}


	//Chain Bar Code
  	/*if(vexRT[Btn6U]){
  		setcBarSpeed(127);
  		cAim = SensorValue[cBar];
  	}
  	else if(vexRT[Btn6D]){
  		setcBarSpeed(-127);
  		cAim = SensorValue[cBar];
  	}
  	else{
  		int error = SensorValue[cBar] - cAim;
  		setcBarSpeed(error * ckP);
  	}
  	if(vexRT[Btn7U]){
  		int error = 100;
  		setcBarSpeed(error * ckP);
  	}
  	if(vexRT[Btn7D]){
  		int error = 400;
  		setcBarSpeed(error * ckP);
  	}*/

  	//Claw Code
		if(vexRT[Btn8L])
		{
			setClaw(127/3);
		}
		if(vexRT[Btn8R])
		{
			setClaw(-127/3);
		}
		if(vexRT[Btn7R])
		{
			setClaw(0);
		}




 		if(vexRT[Btn6U]){
 			setcBarSpeed(-127);
 		}
 		else if(vexRT[Btn6D]){
 			setcBarSpeed(127);
 		}
 		else{
 			setcBarSpeed(0);
 		}
	/*	e = des - SensorValue[cb];
		int derivative = e - el;
		integral += e;
		wait1Msec(10);
		el = e;
		motor[cBar] = (ckP * e) + (ckI * integral) + (ckD * derivative);(*/
  }
}


void setMogo(int speed){
	motor[mogoL] = speed;
	motor[mogoR] = speed;
}
void setLDrive(int speed){
	motor[LDB] = speed;
	motor[LDF] = speed;
}

void setRDrive(int speed){
	motor[RDB] = speed;
	motor[RDF] = speed;
}
void setLiftSpeed(int speed){
	motor[LiftL] = speed;
	motor[LiftR] = speed;
}
void setcBarSpeed(int speed){
	motor[cBar] = speed;
}
void setClaw(int speed){
	motor[claw] = speed;
}
void chBar(int des){
	float ckP = -0.11;
	float ckI = 0.0005;
	float ckD = -0.25;
	int integral = 0;
	int e = des - SensorValue[cb];
	int el = 0;
//	motor[claw] = -50;
	while(1){
		e = des - SensorValue[cb];
		int derivative = e - el;
		integral += e;
		wait1Msec(30);
		el = e;
		motor[cBar] = (ckP * e) + (ckI * integral) + (ckD * derivative);

	}
}
/*
void chainBar(int pos){
	int kP = -2;
	while(1){

		sensorC = SensorValue[cb];
		int error = SensorValue[cb] - pos;
		int final = error*kP + 25;
		motor[cBar] = final;
		errorOut = error;
		finalOut = final;
		wait1Msec(30);
	}
}*/
