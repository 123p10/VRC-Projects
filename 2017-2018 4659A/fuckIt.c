#pragma config(Sensor, dgtl1,  DriveR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  DriveL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Mogo,           sensorQuadEncoder)
#pragma config(Motor,  port1,           MogoR,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           DriveR1,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           DriveR2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           DriveR3,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           DriveL3,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           DriveL2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           DriveL1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          MogoL,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define JOYSTICK_THRESHOLD 15
#define ASYNC_MOGO_DONE_THRESHOLD 10

#define TIME_INCREMENT 50
#define SIZE_RECORD (60*1000)/TIME_INCREMENT

/*
 ______   ______   ______   ______  _________
|      | |      | |      | |      |     |
|      | |      | |      | |      |     |
|______| |      | |_____|  |      |     |
|  |     |      | |      | |      |     |
|    |   |      | |      | |      |     |
|      | |______| |______| |______|     |
*/

int currentFrame = 0;

void resetDriveSensors();

bool play();

bool recording = false;
void record();

int driveLValues[] = {
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
6,
7,
7,
7,
7,
7,
7,
7,
9,
9,
9,
22,
24,
23,
23,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
22,
32,
33,
33,
32,
32,
32,
32,
32,
33,
42,
43,
43,
43,
44,
44,
44,
44,
44,
43,
43,
39,
39,
36,
35,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
33,
35,
36,
36,
37,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
38,
39,
39,
39,
39,
40,
41,
41,
42,
42,
42,
42,
42,
42,
42,
42,
42,
42,
42,
42,
43,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
44,
45,
45,
61,
72,
72,
72,
71,
71,
71,
70,
70,
69,
68,
68,
68,
66,
66,
66,
66,
65,
64,
60,
60,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,\
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1
};

void resetDriveSensors()
{
	SensorValue[DriveL] = 0;
	SensorValue[DriveR] = 0;
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
	SensorValue[Mogo] = 0;
	resetDriveSensors();
}

task autonomous()
{
}

task usercontrol()
{
	int DriveX = 0;
	int DriveY = 0;
	while(true)
	{
		/*if (abs(vexRT[Ch3]) > JOYSTICK_THRESHOLD) DriveX = vexRT[Ch3];
		else DriveX = 0;
		if (abs(vexRT[Ch4]) > JOYSTICK_THRESHOLD) DriveY = vexRT[Ch4];
		else DriveY = 0;

		if (abs(vexRT[Ch2]) > JOYSTICK_THRESHOLD)
		{
			motor[MogoL] = motor[MogoR] = vexRT[Ch2];
		}
		else
		{
			motor[MogoL] = motor[MogoR] = 0;
		}*/

		motor[DriveL1] = motor[DriveL2] = motor[DriveL3] = vexRT[Ch2];
		//motor[DriveR1] = motor[DriveR2] = motor[DriveR3] = DriveX - DriveY;

		if(vexRT[Btn7R])
		{
			writeDebugStreamLine("RECORDING START");
			recording = true;
			while(play());
		//	record();
		}

		if(vexRT[Btn7L])
		{
			writeDebugStreamLine("RECORDING END");
			recording = false;
		}

		if(recording)
		{
			record();
		}
	}
}

bool play()
{
	motor[DriveL1] = motor[DriveL2] = motor[DriveL3] = driveLValues[currentFrame];
	motor[DriveR1] = motor[DriveR2] = motor[DriveR3] = 0;
	wait1Msec(50);
	if(currentFrame > sizeof(driveLValues)/sizeof(DriveLValues[0]))
	{
		return false;
	}
	else
	{
		currentFrame++;
		return true;
	}
}

void record()
{
	writeDebugStreamLine("%d,", motor[DriveL1]);
	wait1Msec(50);
}
