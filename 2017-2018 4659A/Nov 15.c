#pragma config(Sensor, dgtl1,  Lift,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  dl,             sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  dr,             sensorQuadEncoder)
#pragma config(Motor,  port1,           mogoL,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LM,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LD,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           RD,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RM,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mogoR,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	LD = Left front motor and left back motor
	LM = Left middle motor
	RD = right front motor and right back motor
	RM = right middle motor
*/

task liftControl();
task usercontrol();
//void pre_auton();
task autonomous();
void drive(int dist);
void turn(int distR);
void moveLift(int h);

int desiredLiftPos;
int AUTON_SELECT = 1;

#pragma platform(VEX2)
//CHANGE THIS AFTER
//#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

void pre_auton()
{
	SensorValue[Lift] = 0;
}

task autonomous()
{
	if(AUTON_SELECT == 1){

	}
}


task usercontrol()
{
	int mogoV = 0;
	const int SIZE = 10;
	int oldL[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int oldR[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int sumL = 0, sumR = 0;
	int driveMap[128] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		22,23,24,25,26,27,28,28,29,29,
		30,30,31,31,32,32,33,33,34,34,
		35,35,36,36,37,37,38,38,39,39,
		40,40,41,41,42,42,43,43,44,44,
		45,45,46,46,47,47,48,48,49,49,
		50,50,51,51,52,52,53,53,54,54,
		55,55,56,56,57,57,58,58,59,59,
		60,60,61,62,63,64,65,66,67,68,
		69,70,71,72,73,74,75,76,77,78,
		79,80,81,82,83,84,85,86,87,88,
		89,90,91,92,94,96,127,127};
	//startTask(liftControl);
	while (true)
	{
		int liftV = 0;
	/*	oldL[9] = driveMap[abs(vexRT[Ch3])] * sgn(vexRT[Ch3]);
		oldR[9] = driveMap[abs(vexRT[Ch2])] * sgn(vexRT[Ch2]);
		sumL = 0;
		sumR = 0;
		for(int i = 0; i < SIZE - 1; i++){
			sumL += oldL[i];
			sumR += oldR[i];
			oldL[i] = oldL[i + 1];
			oldR[i] = oldR[i + 1];
		}
		sumL += oldL[9];
		sumR += oldR[9];
		motor[LD]  = sumL / SIZE;
		motor[LM]   = sumL / SIZE;
		motor[RD] = sumR / SIZE;
		motor[RM]  = sumR / SIZE;
		wait1Msec(25);*/

	motor[LD] = vexRT[Ch3];
	motor[LM] = vexRT[Ch3];
	motor[RD] = vexRT[Ch2];
	motor[RM] = vexRT[Ch2];
	motor[R2] = vexRT[Ch2];
	/*(vexRT[Btn8U]){
		motor[LD] = 127;

		motor[LM] =127;


		motor[RD] =127;

		motor[RM] = 127;
	}*/
		if(vexRT[Btn6U]){
			motor[claw] = 127;
		}
		else if(vexRT[Btn6D]){
			motor[claw] = -127;
		}
		else{
			motor[claw] = 0;
		}

		if(vexRT[Btn8U]){
			mogoV = 127;
		}
		else if(vexRT[Btn8D]){
			mogoV = -127;
		}
		else{
			mogoV = 0;
		}
		motor[mogoL] = ,  mogoV;
		motor[mogoR] = mogoV;

  if(vexRT[Btn5U]){
  //	motor[liftL] = liftV;
  //	motor[liftR] = liftV;
 	 liftV = 127;
	}
	else if(vexRT[Btn5D]){
		liftV = -127;
	}
	else{
		liftV = 15;
	}
	motor[liftL] = liftV;
	motor[liftR] = liftV;
}
}
task liftControl(){

	//IDK values
	int E_STOP = 100;
	desiredLiftPos = SensorValue[Lift];
	int liftV = 0;
	bool swap = false;
	int div;
	while(true){
		if(vexRT[Btn5U]){
			liftV = 127;
			swap = true;
		}
		else if(vexRT[Btn5D] ){
			liftV = -127;
			swap = true;
			if(desiredLiftPos < E_STOP){
				liftV = 15;
			}
		}
		else{
		//	liftV = 0;
	/*		if(swap){
				desiredLiftPos = SensorValue[Lift];
				swap = false;
			}
			if(abs(desiredLiftPos - SensorValue[Lift]) > (float) 30 * (float) 11.6 && SensorValue[Lift] < desiredLiftPos){
				div = 1;
			}
			else if(abs(desiredLiftPos - SensorValue[Lift]) > (float) 10 * (float) 11.6  && SensorValue[Lift] < desiredLiftPos)
			{
				div = 3;
			}
			else
			{
				div = 6;
			}
			liftV = (desiredLiftPos - SensorValue[Lift]) / div;
		}*/
			liftV = 15;
		}

		motor[liftL] = liftV;
		motor[liftR] 	= liftV;
		wait1Msec(30);
	}

}

void drive(int dist){
	int kP = 2;
	//convert to tenths of an inch
	int d = (28.7 * dist) / 10;
	int speed = 75;
	int lError;
	int rError;
	int le;
	int lSignal;
	int rSignal;
	SensorValue[LD] = 0;
	SensorValue[RD] = 0;
	while(d - SensorValue[LD] > 4095){
		lError = d - SensorValue[LD];
		rError = d - SensorValue[RD];
		le = lError - rError;
		lSignal = speed - (le * kP);
		rSignal = speed + (le * kP);
		motor[LM] = lSignal;
		motor[LD] = lSignal;
		motor[RM] = rSignal;
		motor[RD] = rSignal;
		wait1Msec(25);
	}
	motor[LM] = 0;
	motor[LD] = 0;
	motor[RM] = 0;
	motor[RD] = 0;
}
void turn(int distR){
	SensorValue[LD] = 0;
	SensorValue[RD] = 0;
	while(true){
		//distR = turn left
		//distL = turn right
		if(distR > 0){
			motor[RD] = 127;
			motor[RM] = 127;
			motor[LM] = -127;
			motor[LD] = -127;
			if(distR - SensorValue[dl] < 100){
				motor[LM] = -15;
				motor[LD] = -15;
				motor[RM] = -15;
				motor[RD] = -15;
				wait1Msec(100);
				break;
			}
		}
		else{
			motor[RD] = -127;
			motor[RM] = -127;
			motor[LM] = 127;
			motor[LD] = 127;
			if(distR - SensorValue[dr] < -100){
				motor[LM] = -15;
				motor[LD] = -15;
				motor[RM] = -15;
				motor[RD] = -15;
				wait1Msec(100);
				break;
			}
		}
		wait1Msec(50);
	}
	motor[LM] = 0;
	motor[LD] = 0;
	motor[RM] = 0;
	motor[RD] = 0;
}
void moveLift(int h){
	if(SensorValue[Lift]){

	}
}
