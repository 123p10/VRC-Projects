#pragma config(Sensor, in1,    anglerrE,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  driveR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  driveL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  punchE,         sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           dBR,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           dMR,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           dFR,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           puncher,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           angler,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           dFL,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           dML,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           dBL,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void setLDrive(int s);
void setRDrive(int s);
void setDrive(int l,int r);
void setPuncher(int s);
void setIntake(int s);
void setAngler(int s);
void drivePID(int err);
void turnEncoder(int dist);

void driveBase();
void puncherFunc();
void intakeFunc();
void anglerFunc();
//Constants
const int const_puncher = 300;

int angle = 0;
	const int SIZE = 10; //If updating SIZE, add or remove 0s from arrays below
	int oldL[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  int oldR[SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  int sumL = 0, sumR = 0;

  //Higher control drive mapping
  int driveMap[128] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
											 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
											22,23,24,25,26,27,28,28,29,29,
											30,30,31,31,32,32,33,33,34,34,
											35,35,36,36,37,37,38,38,39,39,
											40,40,41,41,42,42,43,43,44,44,
											45,45,46,46,47,47,48,48,49,49,
											50,50,51,51,52,52,53,53,54,54,
											55,55,56,56,57,57,58,58,59,59,
											60,60,61,62,63,64,65,66,67,68,
											69,70,71,72,73,74,75,76,77,78,
											79,80,81,82,83,84,85,86,87,88,
											89,90,91,92,94,96,127,127};


double angler_kP = 0.5;
void pre_auton()
{
	SensorValue[punchE] = 0;
	SensorValue[driveL] = 0;
	SensorValue[driveR] = 0;
	SensorValue[anglerE] = 0;
}
task autonomous()
{
	drivePID(100);
}

task usercontrol()
{

  while (true)
  {
		driveBase();
		puncherFunc();
		intakeFunc();
		anglerFunc();
		wait1Msec(25);
  }
}


void intakeFunc(){
	//Insert auto intake code
	if(vexRT[Btn6U]){
		setIntake(127);
	}
	else if(vexRT[Btn6D]){
		setIntake(-127);
	}
	else{
		setIntake(0);
	}
}

void anglerFunc(){
	if(vexRT[Btn5U]){
		setAngler(60);
	}
	else if(vexRT[Btn5D]){
		setAngler(-60);
	}
	else{
		setAngler(0);
	}
}
void autoAngler(){
	int expected = 0;
	if(angle == 0){expected = 100;}
	int error = SensorValue[anglerE] - expected;
	setAngler(error * angler_kP);
}

void puncherFunc(){
	//Insert code for auto ratchet
	if(vexRT[Btn8U]){
		setPuncher(-127);
	}
	else{
		setPuncher(0);
	}
	if(abs(SensorValue[punchE]) - abs((SensorValue[punchE] / 4096) * 4096) < const_puncher){
	//	setPuncher(-90);
	}
//	if(SensorValue[punchE])
/*	else{
		setPuncher(0);
	}*/

}

void driveBase(){
	if(abs(vexRT[Ch3]) > 25){
		setLDrive(vexRT[Ch3]);
	}
	else{
		setLDrive(vexRT[Ch3]);
	}
	if(abs(vexRT[Ch2]) > 25){
		setRDrive(vexRT[Ch2]);
	}
	else{
		setRDrive(vexRT[Ch2]);
	}
}


void setAngler(int s){
	motor[angler] = s;
}

void setIntake(int s){
	motor[intake] = s;
}


void setPuncher(int s){
	motor[puncher] = s;
}

void setDrive(int l,int r){
	setLDrive(l);
	setRDrive(r);
}

void setLDrive(int s){
	motor[dBL] = s;
	motor[dML] = s;
	motor[dFL] = s;
}

void setRDrive(int s){
	motor[dBR] = s;
	motor[dMR] = s;
	motor[dFR] = s;
}



//AUTO FUNCTIONS

void drivePID(int err){

	err = (35.3 * err) / 10;


	setDrive(0,0);
	SensorValue[driveR] = 0;
	SensorValue[driveL] = 0;
	int leftError, rightError, leftMotor, rightMotor,error;
	int consis = 70;
	const int tolerance = 10;
	const float kP = 0.5,kD = 0,kI = 0;
	bool isDone = false;

	while(abs(SensorValue[driveL]) < abs(err) - tolerance || abs(SensorValue[driveR]) < abs(err) - tolerance){
		if(abs(SensorValue[driveL]) < abs(err) - tolerance || abs(SensorValue[driveR]) < abs(err) - tolerance){
			leftError = err - SensorValue[driveL];
			rightError = err - SensorValue[driveR];
			error = leftError - rightError;
			rightMotor += consis + error * kP;
			leftMotor -= consis + error * kP;
			setDrive(leftMotor,rightMotor);
			wait1Msec(50);
		}
		if(abs(err) - abs(SensorValue[driveL]) < 30){
			leftMotor -= leftMotor * 0.1;
			rightMotor -= rightMotor * 0.1;
		}
	}
	setDrive(0,0);
}

void turnEncoder(int dist){
  SensorValue[driveL] = 0;
  SensorValue[driveR] = 0;
  int turningSpeed = 70;
  setLDrive(turningSpeed * sgn(dist));
  setRDrive(turningSpeed * sgn(dist) * -1);
  int error = dist - SensorValue[driveL];
  while(error * sgn(dist) > 0){
      if(abs(error) < 200){
        turningSpeed = 40;
      }
      setLDrive(turningSpeed * sgn(dist));
      setRDrive(turningSpeed * sgn(dist) * -1);
      error = dist - SensorValue[driveL];
      delay(50);
  }
  setDrive(-10 * sgn(dist), 10 * sgn(dist));
  delay(75);
  setDrive(0, 0);
}
